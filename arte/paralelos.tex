\chapter{Estado del Arte: Entornos paralelos}

La computación paralela \cite{kumar} ha tenido un tremendo impacto en una gran cantidad de áreas de investigación, desde simulaciones para la ciencia, hasta su aplicación en aplicaciones comerciales para tareas de minería de datos y procesamiento de transacciones.\\

Se está produciendo una revolución en entornos HPC (High Performance Computing) para aplicaciones científicas, concretamente el International Human Genome Sequencing Consortium ha abierto nuevas fronteras en el campo de la bioinformática. El objetivo es el de caracterizar los genes, funcional y estructuralmente, para entender la influencia de los procesos biológicos, analizar las secuencias de genoma con vistas al desarrollo de nuevos medicamentos y desarrollar curas para las enfermedades. Todos estos objetivos están siendo posibles gracias a la computación paralela. La computación paralela no sólo se limita a este campo, también tenemos avances en física, química, astrofísica\ldots\\

La bioinformática presenta uno de los problemas más difíciles de abordar, el tratamiento de grandes bancos de datos o \textit{datasets}. Estos bancos de datos pueden llegar a ser de los más grandes en el ámbito científico, por lo que analizarlos puede requerir una gran capacidad de computo que actualmente solo puede ser abordado por métodos paralelos.\\

En esta sección se discutirán los principales modelos de programación paralela que se utiliza actualmente, acompañados de algunas de sus implementaciones prácticas. Para ello se introducirá la clasificación de las diferentes plataformas paralelas según la Taxonomía de Flynn, puesto que nos permite clasificar tanto los modelos de programación paralela como los sistemas de cómputo.\\

\section{Taxonomía de Flynn}
\label{sec:flynn}

La taxonomía de Flynn \cite{flynn72,openmpquinn} establece una clasificación general de los sistemas paralelos, basándose en las interacciones entre los flujos de datos y los flujos de instrucciones. Es importante caracterizar los sistemas paralelos que se quieren abordar, puesto que dependiendo de sus características unas soluciones serán más viables que otras.\\

En primer lugar tenemos los sistemas \textit{Single Instruction Single Data} (\textit{SISD}), los cuales tienen un único flujo de instrucciones sobre un único flujo de datos. Actualmente los monoprocesadores (con un solo flujo de instrucción, hilo o \textit{thread}) son el ejemplo más claro de este grupo. En general este grupo engloba cualquier máquina secuencial.\\

Después tenemos los sistemas \textit{Single Instruction Single Data} (\textit{SIMD}), los cuales tienen un único flujo de instrucciones sobre múltiples flujos de datos. En la actualidad este tipo de sistemas están en auge, ya que hace unos años no se concebían para computación paralela en ámbitos científicos o de altas prestaciones. El ejemplo más directo son las unidades de procesamiento de gráficos (\textit{GPU}), las cuales están siendo ampliamente utilizadas en computación científica.\\

Los sistemas \textit{Multiple Instruction Single Data} (\textit{MISD}) tienen varios flujos de instrucciones sobre un único flujo de datos. Para encontrar actualmente un ejemplo sobre este tipo de sistema hay que irse, por ejemplo, al interior de un procesador (sistemas segmentados). La decodificación segmentada que realiza sobre las instrucciones que tiene que realizar es un sistema MISD, puesto que para cada instrucción que tiene que realizar, le aplica siempre el mismo proceso (búsqueda, decodificación, ejecución\dots).\\

Por último tenemos los sistemas \textit{Multiple Instruction Multiple Data} (\textit{MIMD}), que son los más extendidos actualmente. Estos sistemas aplican múltiples flujos de instrucciones sobre múltiples flujos de datos. El ejemplo más claro lo tenemos en los multiprocesadores, donde podemos ejecutar varios procesos simultáneamente sobre varios conjuntos de datos. A mayor escala tendríamos los \textit{cluster}, que consisten en grupos de procesadores interconectados para realizar varios procesos de forma simultanea.\\

Aunque esta clasificación se formuló hace unos 40 años, hoy día sigue siendo válida y nos permite caracterizar prácticamente todos los sistemas paralelos.\\

\input{arte/modelos}
%\input{arte/api}